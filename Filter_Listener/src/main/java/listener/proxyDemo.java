package listener;

public class proxyDemo {
    //代理模式和动态代理都是面向对象编程中的设计模式，它们用于在不改变原始对象的情况下，控制对原始对象的访问，并添加一些额外的功能。以下是对这两种模式的解读：
    //代理模式：
    //代理模式是一种结构型设计模式，其目的是为了控制对某个对象的访问，以便在访问对象之前或之后添加一些额外的逻辑。代理模式通常涉及两个角色：
    //抽象角色（Subject）： 定义了代理对象和真实对象之间的接口，以确保它们具有相同的方法。代理模式中的代理类和真实类都应该实现这个接口。
    //代理角色（Proxy）： 代理对象实现了抽象角色的接口，并持有对真实对象的引用。它可以控制对真实对象的访问，可以在访问真实对象之前或之后执行一些额外的操作。
    //真实角色（Real Subject）： 真实对象是代理模式中的核心对象，它执行实际的业务逻辑。

    //代理模式的经典应用场景包括：
    //远程代理：控制访问远程对象。
    //虚拟代理：控制访问昂贵资源，延迟加载等。
    //安全代理：控制对象的访问权限。
    //缓存代理：为一些开销大的运算提供缓存，提高性能。

    //动态代理：
    //动态代理是一种特殊的代理模式，它在运行时创建代理对象，而不是在编译时创建。Java中的动态代理通常使用Java反射机制实现。
    // 动态代理不需要为每个被代理的类编写一个专门的代理类，而是在运行时根据接口或类生成代理对象。
    //Java动态代理主要依赖于两个类：java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler。
    // 代理对象在运行时动态创建，可以拦截对代理对象的方法调用并在调用前后执行一些额外的逻辑。
    //
    //动态代理的应用场景包括：
    //AOP（面向切面编程）：通过动态代理，可以在方法调用前后插入横切逻辑，例如日志记录、事务管理、性能监控等。
    //远程方法调用（RMI）：动态代理可以用于创建远程对象的代理，使得客户端可以调用远程服务器上的方法。
    //框架扩展：许多框架和库使用动态代理来扩展其功能，例如Spring框架中的事务管理。
    //总之，代理模式和动态代理都是在软件设计中用于控制对象访问的强大工具。代理模式通常是在编译时实现的，而动态代理是在运行时动态生成的，
    //可以更灵活地适应各种场景。两者都有助于将横切关注点从业务逻辑中分离出来，提高了代码的可维护性和可复用性。


//    Proxy.newProxyInstance() 是 Java 提供的一个方法，用于创建动态代理对象。它接受三个参数：
//
//    第一个参数是类加载器，通常使用被代理类的类加载器。
//    第二个参数是一个 Class 数组，表示被代理类实现的接口。
//    第三个参数是一个 InvocationHandler 实现，用于处理方法调用。
//            lenovo.getClass().getClassLoader() 获取了 lenovo 对象所属的类的类加载器，通常用于加载被代理类。
//
//            lenovo.getClass().getInterfaces() 获取了 lenovo 对象所属类实现的接口数组。
//
//            new InvocationHandler() {...} 创建了一个匿名内部类，实现了 InvocationHandler 接口。这个接口有一个方法 invoke()，该方法在代理对象的方法被调用时会被执行。这个方法接收三个参数：
//
//    proxy：代理对象自身，通常在方法中不会直接使用它。
//    method：表示被调用的方法对象。
//    args：表示方法的参数。
}
